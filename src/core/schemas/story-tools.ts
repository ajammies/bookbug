/**
 * Draft Tools: Auto-generated tools from StoryDraft schema
 *
 * Tools are generated by introspecting the schema, not manually defined.
 * This eliminates duplication and ensures tools match schema exactly.
 *
 * Following Carmack: "Code so simple, we wonder why we can't develop like him"
 */
import { tool } from 'ai';
import { z } from 'zod';
import {
  StoryDraftSchema,
  PlotBeatSchema,
  getCleanDescription,
  type StoryDraft,
  type PlotBeat,
} from './draft';
import { StoryCharacterSchema, type StoryCharacter } from './common';

// ============================================================================
// Types
// ============================================================================

export interface DraftState {
  draft: Partial<StoryDraft>;
  isComplete: boolean;
}

export interface ToolResult {
  success: boolean;
  message: string;
}

// ============================================================================
// Helper to capitalize field names for tool naming
// ============================================================================

const capitalize = (s: string): string => s.charAt(0).toUpperCase() + s.slice(1);

// ============================================================================
// Tool Generators
// ============================================================================

/**
 * Create a setter tool for a scalar field
 */
const createSetterTool = <T>(
  fieldName: string,
  fieldSchema: z.ZodTypeAny,
  state: DraftState
) => {
  const description = getCleanDescription(fieldSchema.description) || `Set ${fieldName}`;

  return tool({
    description: `Set the ${fieldName}`,
    inputSchema: z.object({
      value: fieldSchema.describe(description),
    }),
    execute: async ({ value }): Promise<ToolResult> => {
      (state.draft as Record<string, unknown>)[fieldName] = value;
      return { success: true, message: `${capitalize(fieldName)} set` };
    },
  });
};

/**
 * Create an adder tool for an array field
 */
const createAdderTool = (
  fieldName: string,
  elementSchema: z.ZodTypeAny,
  state: DraftState
) => {
  const singularName = fieldName.replace(/s$/, '');
  const isPrimitive = ['ZodString', 'ZodNumber', 'ZodBoolean'].includes(elementSchema._def.typeName);

  // For primitives, wrap in { value } like setter tools; for objects, use schema directly
  const inputSchema = isPrimitive
    ? z.object({ value: elementSchema })
    : elementSchema;

  return tool({
    description: `Add a ${singularName} to the story`,
    inputSchema,
    execute: async (input): Promise<ToolResult> => {
      // Extract value for primitives, use input directly for objects
      const item = isPrimitive ? (input as { value: unknown }).value : input;
      const arr = (state.draft as Record<string, unknown[]>)[fieldName];
      if (!arr) {
        (state.draft as Record<string, unknown[]>)[fieldName] = [item];
      } else {
        arr.push(item);
      }
      return { success: true, message: `Added ${singularName}` };
    },
  });
};

// ============================================================================
// Main Tool Factory
// ============================================================================

/**
 * Create all draft tools bound to a state object
 *
 * Generates tools automatically from schema introspection:
 * - Scalar fields -> setX tools
 * - Array fields -> addX tools
 * - Plus conversation tools (promptUser, finishIntake)
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const createDraftTools = (state: DraftState): Record<string, any> => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const tools: Record<string, any> = {};

  // Generate tools from schema shape
  for (const [fieldName, fieldSchema] of Object.entries(StoryDraftSchema.shape)) {
    const schema = fieldSchema as z.ZodTypeAny;
    const typeName = schema._def.typeName;

    // Handle optional wrapper
    const innerSchema = typeName === 'ZodOptional' || typeName === 'ZodDefault'
      ? schema._def.innerType
      : schema;
    const innerTypeName = innerSchema._def.typeName;

    if (innerTypeName === 'ZodArray') {
      // Array field -> addX tool
      const elementSchema = innerSchema._def.type;
      tools[`add${capitalize(fieldName.replace(/s$/, ''))}`] = createAdderTool(
        fieldName,
        elementSchema,
        state
      );
    } else {
      // Scalar field -> setX tool
      tools[`set${capitalize(fieldName)}`] = createSetterTool(fieldName, innerSchema, state);
    }
  }

  // Add conversation tools (not auto-generated)
  tools.promptUser = tool({
    description: 'Present a question to the user with suggested options',
    inputSchema: z.object({
      question: z.string().min(1).describe('The question to ask the user'),
      options: z.array(z.string().min(1)).min(2).max(8)
        .describe('2-8 specific options. Never include "Other" or "None" - UI provides custom input'),
    }),
    execute: async ({ question, options }): Promise<ToolResult> => {
      return { success: true, message: `Asked: "${question}" with ${options.length} options` };
    },
  });

  tools.finishIntake = tool({
    description: 'Signal that draft is complete. Only call when all required fields are filled.',
    inputSchema: z.object({
      summary: z.string().optional().describe('Brief summary of the story'),
    }),
    execute: async ({ summary }): Promise<ToolResult> => {
      state.isComplete = true;
      return { success: true, message: summary ?? 'Draft complete' };
    },
  });

  // Add specialized character tool (characters need name-based update)
  tools.updateCharacter = tool({
    description: 'Update an existing character by name',
    inputSchema: z.object({
      name: z.string().min(1).describe('Name of the character to update'),
      updates: z.object({
        description: z.string().optional(),
        role: z.string().optional(),
        traits: z.array(z.string()).optional(),
        visualDescription: z.string().optional(),
      }).describe('Fields to update'),
    }),
    execute: async ({ name, updates }): Promise<ToolResult> => {
      const characters = state.draft.characters;
      if (!characters) {
        return { success: false, message: `Character "${name}" not found` };
      }
      const char = characters.find(c => c.name.toLowerCase() === name.toLowerCase());
      if (!char) {
        return { success: false, message: `Character "${name}" not found` };
      }
      if (updates.description !== undefined) char.description = updates.description;
      if (updates.role !== undefined) char.role = updates.role;
      if (updates.traits !== undefined) char.traits = updates.traits;
      if (updates.visualDescription !== undefined) char.visualDescription = updates.visualDescription;
      return { success: true, message: `Updated character: ${name}` };
    },
  });

  // Add specialized plot beat tool (beats need index-based update)
  tools.updatePlotBeat = tool({
    description: 'Update an existing plot beat by index',
    inputSchema: z.object({
      index: z.number().int().describe('Index of the beat (0-based)'),
      purpose: z.enum(['setup', 'build', 'conflict', 'twist', 'climax', 'payoff', 'button']).optional(),
      description: z.string().optional(),
    }),
    execute: async ({ index, purpose, description }): Promise<ToolResult> => {
      const beats = state.draft.plotBeats;
      if (!beats || index >= beats.length) {
        return { success: false, message: `Plot beat at index ${index} not found` };
      }
      const beat = beats[index];
      if (!beat) {
        return { success: false, message: `Plot beat at index ${index} not found` };
      }
      if (purpose) beat.purpose = purpose;
      if (description) beat.description = description;
      return { success: true, message: `Updated plot beat ${index}` };
    },
  });

  return tools;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type DraftTools = Record<string, any>;
